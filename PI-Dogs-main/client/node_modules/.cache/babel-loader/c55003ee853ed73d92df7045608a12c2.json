{"ast":null,"code":"const initialState = {\n  dogs: [],\n  allDogs: [],\n  //hago una copia del estado que siempre tenga todos los dogs para que me haga los filtros sobre todo y no sobre el estado que ya filtré\n  orderDogs: [],\n  //de esta manera no tengo que volver a cargar a todos los perros\n  weightDogs: [],\n  temperaments: [],\n  //declaro un nuevo estado temperament donde guardo los temperamentos\n  detail: [] //creo un nuevo estado detail para guardar la info del detalle del perro\n\n};\nexport function rootReducer() {\n  var _state$allDogs, _state$allDogs2;\n\n  let state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialState;\n  let action = arguments.length > 1 ? arguments[1] : undefined;\n\n  switch (action.type) {\n    case 'GET_DOGS':\n      return { ...state,\n        dogs: action.payload,\n        allDogs: action.payload\n      };\n\n    case \"DOG_DETAIL\":\n      //al hacer click sobre un perro accedo a sus detalles\n      return { ...state,\n        detail: action.payload // a detail que es el estado que está creado arriba, pasale action.payload\n\n      };\n\n    case \"GET_DOGS_BY_NAME\":\n      return { ...state,\n        dogs: action.payload //lo renderizo en el array dogs, este es el filtrado de buscar por nombre que hice en el back\n\n      };\n\n    case \"GET_TEMPERAMENTS\":\n      return { ...state,\n        temperaments: action.payload\n      };\n\n    case \"POST_DOG\":\n      //post dog tiene que estar en el reducer pero no hace nada, porque yo creo un dog en una ruta nueva\n      return { ...state\n      };\n\n    case CREATED_OR_NOT:\n      const createdOrNot = action.payload === 'Created' ? (_state$allDogs = state.allDogs) === null || _state$allDogs === void 0 ? void 0 : _state$allDogs.filter(d => d.createdInDB === true) : (_state$allDogs2 = state.allDogs) === null || _state$allDogs2 === void 0 ? void 0 : _state$allDogs2.filter(d => !d.createdInDB);\n      return { ...state,\n        dogs: action.payload === 'All' ? state.allDogs : createdOrNot\n      };\n\n    case \"FILTER_BY_TEMP\":\n      const allDogs = state.allDogs;\n      const filteredDogs = allDogs.filter(el => {\n        var _el$temperament;\n\n        return (_el$temperament = el.temperament) === null || _el$temperament === void 0 ? void 0 : _el$temperament.includes(action.payload);\n      } // action.payload es el temperamento que seleccioné en el filtro de temperamentos que está en el state temperaments y lo que me devuelve es un array de strings con los temperamentos.\n      );\n      return { ...state,\n        dogs: filteredDogs\n      };\n\n    /*el valor del select es lo que va a ser el (e.target.value) y va a llegar a la acción por payload\r\n          includes xque cada perro puede tener varios temperamentos\r\n          y si no, devolveme todos los dogs filtrados\r\n          y en dogs le devuelvo la constante filteredDogs; cuando vuelvo a hacer otro filtro, agarra el que tiene todos (allDogs)\r\n          pero el que va a modificar va a hacer el estado de dogs*/\n\n    case \"ORDER_BY_NAME\":\n      const orderDogs = action.payload === \"Asc\" //Si el valor es \"Asc\"\n      ? state.dogs.sort(function (a, b) {\n        //sort compara dos valores, accedemos al name y los compara, y los coloca a\n        if (a.name > b.name) return 1; //la derecha o a la izquierda, antes o despu{es en el arreglo dependiendo si son mas grandes o mas chicos\n\n        if (b.name > a.name) return -1;\n        return 0; //si son iguales los deja como está\n      }) // y si no, (si es no es Asc es Des) ordeno de Z a A\n      : state.dogs.sort(function (a, b) {\n        if (a.name > b.name) return -1;\n        if (b.name > a.name) return 1;\n        return 0;\n      });\n      return { ...state,\n        dogs: orderDogs\n      };\n\n    case \"ORDER_BY_WEIGHT\":\n      const weightDogs = action.payload === \"Weight 1\" ? state.dogs.sort(function (a, b) {\n        if (typeof action.payload.weight === \"string\") {\n          //si recibo un string con el peso\n          if (a.weight > b.weight) return 1; //accedo al valor weight que quiero comparar\n\n          if (a.weight < b.weight) return -1;\n          return 0; //si son iguales no hace nada, los deja igual\n        } else {\n          // lo convierto en número\n          if (parseInt(a.weight) > parseInt(b.weight)) return 1;\n          if (parseInt(a.weight) < parseInt(b.weight)) return -1;\n          return 0;\n        }\n      }) //si el valor no es 'weight 1'\n      : state.dogs.sort(function (a, b) {\n        //ordeno de mayor a menor\n        if (typeof action.payload.weight === \"string\") {\n          if (a.weight > b.weight) return -1;\n          if (a.weight < b.weight) return 1;\n          return 0;\n        } else {\n          if (parseInt(a.weight) > parseInt(b.weight)) return -1;\n          if (parseInt(a.weight) > parseInt(b.weight)) return 1;\n          return 0;\n        }\n      });\n      return { ...state,\n        dogs: weightDogs\n      };\n\n    default:\n      return state;\n  }\n}\nexport default rootReducer;","map":{"version":3,"sources":["C:/Users/andre/Desktop/DOG-PI/PI-Dogs/PI-Dogs-main/client/src/reducer/index.js"],"names":["initialState","dogs","allDogs","orderDogs","weightDogs","temperaments","detail","rootReducer","state","action","type","payload","CREATED_OR_NOT","createdOrNot","filter","d","createdInDB","filteredDogs","el","temperament","includes","sort","a","b","name","weight","parseInt"],"mappings":"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","sourcesContent":["const initialState = {\r\n    dogs: [],\r\n    allDogs: [], //hago una copia del estado que siempre tenga todos los dogs para que me haga los filtros sobre todo y no sobre el estado que ya filtré\r\n    orderDogs: [], //de esta manera no tengo que volver a cargar a todos los perros\r\n    weightDogs: [],\r\n    temperaments: [], //declaro un nuevo estado temperament donde guardo los temperamentos\r\n    detail: [], //creo un nuevo estado detail para guardar la info del detalle del perro\r\n};\r\n\r\n\r\nexport function rootReducer(state = initialState, action) {\r\n    switch (action.type) {\r\n        case 'GET_DOGS':\r\n            return {\r\n                ...state,\r\n                dogs: action.payload,\r\n                allDogs: action.payload\r\n            }\r\n        case \"DOG_DETAIL\": //al hacer click sobre un perro accedo a sus detalles\r\n            return {\r\n                ...state,\r\n                detail: action.payload, // a detail que es el estado que está creado arriba, pasale action.payload\r\n            };\r\n        case \"GET_DOGS_BY_NAME\":\r\n            return {\r\n                ...state,\r\n                dogs: action.payload, //lo renderizo en el array dogs, este es el filtrado de buscar por nombre que hice en el back\r\n            };\r\n        case \"GET_TEMPERAMENTS\":\r\n            return {\r\n                ...state,\r\n                temperaments: action.payload,\r\n            };\r\n        case \"POST_DOG\": //post dog tiene que estar en el reducer pero no hace nada, porque yo creo un dog en una ruta nueva\r\n            return {\r\n                ...state,\r\n            };\r\n        case CREATED_OR_NOT:\r\n            const createdOrNot = action.payload === 'Created' ? state.allDogs?.filter(d => d.createdInDB === true) : state.allDogs?.filter(d => !d.createdInDB);\r\n            return {\r\n                ...state,\r\n                dogs: action.payload === 'All' ? state.allDogs : createdOrNot\r\n            }\r\n        case \"FILTER_BY_TEMP\":\r\n            const allDogs = state.allDogs;\r\n            const filteredDogs = allDogs.filter(\r\n                (el) => el.temperament?.includes(action.payload) // action.payload es el temperamento que seleccioné en el filtro de temperamentos que está en el state temperaments y lo que me devuelve es un array de strings con los temperamentos.\r\n            );\r\n            return {\r\n                ...state,\r\n                dogs: filteredDogs,\r\n            };\r\n        /*el valor del select es lo que va a ser el (e.target.value) y va a llegar a la acción por payload\r\n              includes xque cada perro puede tener varios temperamentos\r\n              y si no, devolveme todos los dogs filtrados\r\n              y en dogs le devuelvo la constante filteredDogs; cuando vuelvo a hacer otro filtro, agarra el que tiene todos (allDogs)\r\n              pero el que va a modificar va a hacer el estado de dogs*/\r\n        case \"ORDER_BY_NAME\":\r\n            const orderDogs =\r\n                action.payload === \"Asc\" //Si el valor es \"Asc\"\r\n                    ? state.dogs.sort(function (a, b) {\r\n                        //sort compara dos valores, accedemos al name y los compara, y los coloca a\r\n                        if (a.name > b.name) return 1; //la derecha o a la izquierda, antes o despu{es en el arreglo dependiendo si son mas grandes o mas chicos\r\n                        if (b.name > a.name) return -1;\r\n                        return 0; //si son iguales los deja como está\r\n                    }) // y si no, (si es no es Asc es Des) ordeno de Z a A\r\n                    : state.dogs.sort(function (a, b) {\r\n                        if (a.name > b.name) return -1;\r\n                        if (b.name > a.name) return 1;\r\n                        return 0;\r\n                    });\r\n            return {\r\n                ...state,\r\n                dogs: orderDogs,\r\n            };\r\n        case \"ORDER_BY_WEIGHT\":\r\n            const weightDogs =\r\n                action.payload === \"Weight 1\"\r\n                    ? state.dogs.sort(function (a, b) {\r\n                        if (typeof action.payload.weight === \"string\") {\r\n                            //si recibo un string con el peso\r\n                            if (a.weight > b.weight) return 1; //accedo al valor weight que quiero comparar\r\n                            if (a.weight < b.weight) return -1;\r\n                            return 0; //si son iguales no hace nada, los deja igual\r\n                        } else {\r\n                            // lo convierto en número\r\n                            if (parseInt(a.weight) > parseInt(b.weight)) return 1;\r\n                            if (parseInt(a.weight) < parseInt(b.weight)) return -1;\r\n                            return 0;\r\n                        }\r\n                    }) //si el valor no es 'weight 1'\r\n                    : state.dogs.sort(function (a, b) {\r\n                        //ordeno de mayor a menor\r\n                        if (typeof action.payload.weight === \"string\") {\r\n                            if (a.weight > b.weight) return -1;\r\n                            if (a.weight < b.weight) return 1;\r\n                            return 0;\r\n                        } else {\r\n                            if (parseInt(a.weight) > parseInt(b.weight)) return -1;\r\n                            if (parseInt(a.weight) > parseInt(b.weight)) return 1;\r\n                            return 0;\r\n                        }\r\n                    });\r\n            return {\r\n                ...state,\r\n                dogs: weightDogs,\r\n            };\r\n        default:\r\n            return state;\r\n    }\r\n}\r\n\r\nexport default rootReducer;"]},"metadata":{},"sourceType":"module"}